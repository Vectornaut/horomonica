<!DOCTYPE html>

<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!--<link rel="stylesheet" type="text/css" href="" />-->
  <style>
    body {
      color: #c0c0c0;
      background-color: #202020;
      font-family: sans-serif;
    }
    
    a {
      color:  #c0c0c0;
    }
    
    a:hover {
      color:  #f0f0f0;
    }
    
    a:active {
      color:  #ffffff;
    }
    
    div {
      margin: 15px 0 0 30px;
    }
    
    canvas {
      margin: 30px 0 0 30px;
    }
    
    #content {
      margin: 60px 30px 60px 30px;
    }
    
    .control-bar {
      display: flex;
      margin-bottom: 6px;
    }
    
    .control {
      margin: 0 12px 0 0;
      display: flex;
      align-items: center;
    }
    
    .control > input:not(:first-child), select:not(:first-child) {
      margin-left: 8px;
    }
    
    .control > label:not(:first-child) {
      margin-left: 8px;
    }
    
    #tuning {
      display: grid;
      grid-template-rows: auto auto;
      grid-auto-flow: column;
      overflow-x: scroll;
      grid-row-gap: 6px;
      grid-column-gap: 8px;
      padding: 8px 0 8px 0;
    }
    
    #tuning > label {
      text-align: right;
      white-space: nowrap;
    }
    
    #tuning > input[type=text] {
      min-width: 65px;
    }
    
    #tuning > input[type=text]:focus {
      outline: none;
    }
    
    /*
     formatting tips from Stephanie Eckles
     https://moderncss.dev/custom-css-styles-for-form-inputs-and-textareas/
    */
    input {
      background-color: #020202;
      border: 1px solid hsl(0, 0%, 30%);
      border-radius: 4px;
      color: #c0c0c0;
      font-size: inherit;
    }
    
    input.freq0 { border-color: hsl(324, 100%, 50%); }
    input.freq1 { border-color: hsl(36, 100%, 50%); }
    input.freq2 { border-color: hsl(60, 100%, 50%); }
    input.freq3 { border-color: hsl(120, 100%, 50%); }
    input.freq4 { border-color: hsl(187.2, 100%, 50%); }
    input.freq5 { border-color: hsl(288, 83%, 50%); }
    
    input.freq0:focus { box-shadow: 0 0 8px hsl(324, 100%, 50%); }
    input.freq1:focus { box-shadow: 0 0 8px hsl(36, 100%, 50%); }
    input.freq2:focus { box-shadow: 0 0 8px hsl(60, 100%, 50%); }
    input.freq3:focus { box-shadow: 0 0 8px hsl(120, 100%, 50%); }
    input.freq4:focus { box-shadow: 0 0 8px hsl(187.2, 100%, 50%); }
    input.freq5:focus { box-shadow: 0 0 8px hsl(288, 83%, 50%); }
    
    /*input[type=button]:hover {
      background-color: #303030;
    }
    
    input[type=button]:active, input[type=button].pressed {
      color: white;
      background-color: #404040;
      border-color: hsl(0, 0%, 40%);
    }*/
    
    /*input[type=button]:disabled {
      filter: brightness(0.5);*/
      /* colors adjusted to compensave for filter */
      /*background-color: #404040;
      border-color: hsl(0, 0%, 60%);
    }*/
  </style>
  
  <!-- web fonts -->
  <!--<link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">-->
  
  <!-- OpenGL utilities -->
  <script type="text/javascript" src="twgl.min.js"></script>
  <script type="text/javascript" src="gl-matrix-min.js"></script>
  <script type="text/javascript" src="fraction.js"></script>
  
  <!-- shaders -->
  
  <script id="pass-vert" type="text/plain">
    #version 300 es
    
    // inputs
    in vec4 position;
    
    void main() {
      gl_Position = position;
    }
  </script>
  
  <script id="test-frag" type="text/plain">
    #version 300 es
    
    precision highp float;
    
    // outputs
    out vec4 fragColor;
    
    // resolution
    uniform vec2 resolution;
    uniform float shortdim;
    uniform float dpr;
    
    // triangulation
    uniform int next_edge[120];
    uniform float half_shear[60];
    uniform float left_offset[120];
    uniform float right_offset[120];
    uniform float opp_offset[120];
    uniform vec3 edge_color[60];
    uniform int n_edges;
    
    // viewpoint
    uniform int ref_edge;
    uniform mat4 unframe;
    
    // display parameters
    uniform float view;
    uniform vec3 bg_color;
    uniform vec3 bdry_color;
    
    // --- pixel sampling ---
    
    const float A1 = 0.278393;
    const float A2 = 0.230389;
    const float A3 = 0.000972;
    const float A4 = 0.078108;
    
    // Abramowitz and Stegun, equation 7.1.27
    float erfc_appx(float t) {
      float r = abs(t);
      float p = 1. + A1*(r + A2*(r + A3*(r + A4*r)));
      float p_sq = p*p;
      float erfc_r = 1. / (p_sq*p_sq);
      return t < 0. ? (2. - erfc_r) : erfc_r;
    }
    
    // how much of a pixel's sampling distribution falls on the negative side of an
    // edge. `disp` is the pixel's displacement from the edge in pattern space
    float neg_part(float pattern_disp, float scaling, float r_px) {
      // find the displacement to the edge in the screen tangent space
      float screen_disp = pattern_disp / scaling;

      // integrate our pixel's sampling distribution on the screen tangent space to
      // find out how much of the pixel falls on the negative side of the edge
      return 0.5*erfc_appx(screen_disp / r_px);
    }
    
    // find the color of a pixel near an edge between two colored regions.
    // `neg` and `pos` are the colors on the negative and positive sides of the
    // edge. `disp` is the displacement from the edge
    
    float edge_mix(float neg, float pos, float pattern_disp, float scaling, float r_px) {
      return mix(pos, neg, neg_part(pattern_disp, scaling, r_px));
    }
    
    vec3 edge_mix(vec3 neg, vec3 pos, float pattern_disp, float scaling, float r_px) {
      return mix(pos, neg, neg_part(pattern_disp, scaling, r_px));
    }
    
    // how much of a pixel's sampling distribution falls on a thickened line.
    // `width` is the line thickness, in pixels. `pattern_disp` is the pixel's
    // displacement from the line in pattern space
    float line_part(float width, float pattern_disp, float scaling, float r_px) {
      // find the displacement to the edge in the screen tangent space
      float screen_disp = pattern_disp / scaling;
      float screen_disp_px = screen_disp / r_px;
      
      // integrate our pixel's sampling distribution on the screen tangent space to
      // find out how much of the pixel falls within `width/2` of the line
      float lower = erfc_appx(screen_disp_px - 0.5*width);
      float upper = erfc_appx(screen_disp_px + 0.5*width);
      return 0.5*(lower - upper);
    }
    
    vec3 line_mix(vec3 stroke, vec3 bg, float width, float pattern_disp, float scaling, float r_px) {
      return mix(bg, stroke, line_part(width, pattern_disp, scaling, r_px));
    }
    
    vec4 line_mix(vec4 stroke, vec4 bg, float width, float pattern_disp, float scaling, float r_px) {
      return mix(bg, stroke, line_part(width, pattern_disp, scaling, r_px));
    }
    
    // --- triangle walk ---
    
    // left and right turns
    const mat4 left = mat4(
      1., 0., -1.,  0.,
      0., 1.,  0., -1.,
      0., 0.,  1.,  0.,
      0., 0.,  0.,  1.
    );
    const mat4 right = mat4(
       1.,  0., 0., 0.,
       0.,  1., 0., 0.,
      -1.,  0., 1., 0.,
       0., -1., 0., 1.
    );
    
    void main() {
      // the mobius transformation that maps the unit disk to the upper half-
      // plane, fixing 1 and -1
      const mat4 unroll = 1./sqrt(2.) * mat4(
         0., 1.,  1., 0.,
        -1., 0.,  0., 1.,
         1., 0.,  0., 1.,
         0., 1., -1., 0.
      );
      
      // the mobius transformation that gives the upper half-plane a half-turn
      // around `i`
      const mat4 half_turn = mat4(
        0., 0., -1.,  0.,
        0., 0.,  0., -1.,
        1., 0.,  0.,  0.,
        0., 1.,  0.,  0.
      );
      
      // project from the screen to the Poincare disk
      float r_px = view / shortdim; // the inner radius of a pixel in the Euclidean metric of the screen
      vec2 z = r_px * (2.*gl_FragCoord.xy - resolution);
      float r_sq = dot(z, z);
      float proj_scaling = 2. / (1.-r_sq); // the conformal scale factor of the projection
      float width = min(4., 12./sqrt(0.5*proj_scaling));
      
      // triangle walk
      if (r_sq < 1.) {
        // departure
        vec4 v = unframe * unroll * vec4(z, 1., 0.);
        int edge = ref_edge;
        if (dot(v.xy, v.zw) < 0.) {
          v = half_turn * v;
          edge = (edge + n_edges) % (2*n_edges);
        }
        
        // during the walk, we'll use these to see whether we're beyond the left
        // and right sides of the triangle. when we arrive, we'll use them
        // to find the signed distances to the sides of the triangle
        float m; // Re(ab')
        float q_a; // |a|^2
        float q_b; // |b|^2
        
        // `t_side := tanh(d_side)`, where `d_side` is the distance to a side
        // of the triangle
        float t_base;
        float t_left;
        float t_right;
        
        // color sampling
        vec4 fg_color = vec4(0.);
        float fg_alpha = 0.;
        vec4 blur_color = vec4(0.);
        float blur_samples = 0.;
        
        // later steps
        int step; /* for reference edge marking */
        int left_edge;
        int right_edge;
        const int step_max = 20;
        for (/*int*/ step = 0; step < step_max; step++) {
          // shear the opposite vertex to 1
          if (step > 0 || edge != ref_edge) {
            float x = half_shear[edge % n_edges];
            v *= vec4(vec2(1./x), vec2(x));
          }
          
          // set up to find the signed distances to the left and right sides.
          // we look at `v` as a pair `(a, b)` of complex numbers
          m = dot(v.xy, v.zw); // Re(ab')
          q_a = dot(v.xy, v.xy); // |a|^2
          q_b = dot(v.zw, v.zw); // |b|^2
          
          // the base side of the triangle is the geodesic from 0 to infinity
          // in the upper half-plane. the curve through `v` which is
          // equidistant from the base side is a ray which leaves 0 at some
          // angle `phi`. the distance `d_base` from `v` to the base side is
          // given by (Series, "Hyperbolic Geometry: MA 448", section 2.2.7)
          //
          //   t_base := tanh(d_base) = cos(phi)
          //
          float t_base = m / sqrt(q_a * q_b);
          
          // area-sample the edge
          if (abs(t_base) < 16.*(proj_scaling * r_px)) {
            vec4 mix = line_mix(vec4(edge_color[edge % n_edges], 1.), vec4(0.), width, t_base, proj_scaling, r_px);
            fg_color += mix;
            fg_alpha = max(mix.a, fg_alpha);
            blur_color += line_mix(vec4(edge_color[edge % n_edges], 1.), vec4(edge_color[edge % n_edges], 0.), width, 0., proj_scaling, r_px);
            blur_samples += 1.;
          }
          
          left_edge = next_edge[2*edge];
          right_edge = next_edge[2*edge+1];
          if (m > q_a) {
            v = left * v;
            edge = left_edge;
          } else if (m > q_b) {
            v = right * v;
            edge = right_edge;
          } else {
            break;
          }
        }
        
        // --- arrival ---
        
        // find the hyperbolic tangents of the distances to the left and right
        // sides
        float diff = sqrt(dot(v.xy - v.zw, v.xy - v.zw)); // |a - b|
        t_left = (m - q_a) / (sqrt(q_a) * diff);
        t_right = (m - q_b) / (sqrt(q_b) * diff);
        
        // find the conformal scale factor of the Poincare projection
        /*float proj_scaling = 2. / (1.-r_sq);
        float width = min(4., 12./sqrt(0.5*proj_scaling));*/
        
        /* mark the reference edge */
        vec3 color = bg_color;
        if (step == 0 && edge == ref_edge) {
          color = mix(color, edge_color[ref_edge % n_edges], 0.4*exp(-3.*m * (exp(-3.*q_a) + exp(-3.*q_b)) / (q_a*exp(-3.*q_a) + q_b*exp(-3.*q_b))));
        }
        
        // area-sample the left and right edges
        if (abs(t_left) < 16.*(proj_scaling * r_px)) {
          vec4 mix = line_mix(vec4(edge_color[left_edge % n_edges], 1.), vec4(0.), width, t_left, proj_scaling, r_px);
          fg_color += mix;
          fg_alpha = max(mix.a, fg_alpha);
        }
        if (abs(t_right) < 16.*(proj_scaling * r_px)) {
          vec4 mix = line_mix(vec4(edge_color[right_edge % n_edges], 1.), vec4(0.), width, t_right, proj_scaling, r_px);
          fg_color += mix;
          fg_alpha = max(mix.a, fg_alpha);
        }
        if (step >= step_max) {
          blur_color /= blur_samples;
          color = mix(color, blur_color.rgb, blur_color.a);
        } else {
          if (fg_alpha > 0.) fg_color /= fg_color.a;
          color = mix(color, fg_color.rgb, fg_alpha);
        }
        
        /* experimenting with horodiscs */
        float h = v.x*v.w - v.y*v.z; // -Im(ab');
        float left_denom = left_offset[edge] * q_a;
        float right_denom = right_offset[edge] * q_b;
        float opp_denom = opp_offset[edge] * diff*diff;
        float min_denom = min(min(left_denom, right_denom), opp_denom);
        float horo_shade = edge_mix(0., 1., h/min_denom - 1., 2., r_px);
        color = mix(color, vec3(0.5), 0.5*horo_shade);
        
        // area-sample the disk boundary
        color = line_mix(bdry_color, color, 2., r_sq - 1., 2., r_px);
        fragColor = vec4(color, 1.);
      } else {
        fragColor = line_mix(vec4(bdry_color, 1.), vec4(0.), 2., r_sq - 1., 2., r_px);
      }
    }
  </script>
  
  <title>Hormonica</title>
</head>

<body>
  <div id="content">
    <div class="control-bar" id="tuning">
      <label>initial tuning:</label>
      <label>current tuning:</label>
    </div>
    <div class="control-bar">
      <div class="control">
        <label for="surf">surface:</label>
        <select id="surf">
          <option>Sphere, 4 cusps</option>
          <option>Torus, 2 cusps</option>
        </select>
      </div>
    </div>
    <div class="control-bar">
      <div class="control">
        <label for="tone">tone:</label>
        <select id="tone">
          <option>Pure</option>
          <option>Shepard</option>
        </select>
      </div>
    </div>
    <div>tap or click an edge to play a note</div>
    <div>tap or click a triangle to play a chord</div>
    <div>tap an edge while touching outside the disk, or holding <i>shift</i>, to flip it</div>
    <div>use the keys <b>W E R / S D F</b> to scroll</div>
    <canvas id="test" width="650" height="650"></canvas>
    <div>based on Robert Penner&rsquo;s &ldquo;<a href="http://preprints.ihes.fr/2021/M/M-21-12.pdf">Music of moduli spaces</a>&rdquo;</div>
    <div>example pieces: <a href="music/tetra.html">tetra</a> | <a href="music/music-box.html">music box</a></div>
  </div>
  
  <script>
    var mat4 = glMatrix.mat4;
    
    // --- edge colors ---
    
    function hsl2rgb([hue, sat, lite]) {
      const scale = sat*Math.min(lite, 1-lite);
      const shape = off => {
        const t = (off + hue/30) % 12;
        return lite - scale*Math.max(-1, Math.min(t-3, 9-t, 1));
      }
      return [shape(0), shape(8), shape(4)];
    }
    
    var edgeColor = Array.prototype.concat.apply([], [
      [324, 1, 0.5],
      [36, 1, 0.5],
      [60, 1, 0.5],
      [120, 1, 0.5],
      [187.2, 1, 0.5],
      [288, 0.83, 0.50]
    ].map(hsl2rgb));
    console.log(edgeColor);
    
    // --- triangulation data and functions ---
    
    class Triangulation {
      initLambda
      nextEdge
      
      constructor(initLambda, nextEdge) {
        this.initLambda = initLambda;
        this.nextEdge = nextEdge;
      }
    }
    
    function setTriangulation(tri) {
      // initialize shears
      initLambda = tri.initLambda.map(x => x.clone());
      lambda = initLambda.map(x => x.clone());
      n_edges = lambda.length;
      halfLambda = lambda.map(Math.sqrt);
      halfShear = Array(n_edges);
      leftOffset = Array(2*n_edges);
      rightOffset = Array(2*n_edges);
      oppOffset = Array(2*n_edges);
      nextEdge = Array.from(tri.nextEdge);
      updateAllShears();
      updateAllOffsets();
      
      // clear flip stack
      flipStack = [];
      
      // create tuning controls
      tuning = document.querySelector('#tuning');
      while (tuning.lastChild) {
        tuning.removeChild(tuning.lastChild);
      }
      for (let k = 0; k < n_edges; k++) {
        let freq = lambda[k].inverse();
        
        let initFreq = document.createElement('input');
        initFreq.type = 'text';
        initFreq.id = 'init-freq' + String(k);
        initFreq.classList.add('freq' + String(k));
        initFreq.value = freq.toFraction();
        initFreq.addEventListener('change', () => changeInitFreq(k, initFreq));
        
        let currFreq = document.createElement('input');
        currFreq.type = 'text';
        currFreq.id = 'curr-freq' + String(k);
        currFreq.classList.add('freq' + String(k));
        currFreq.value = freq.toFraction();
        currFreq.addEventListener('change', () => changeCurrFreq(k, currFreq));
        
        tuning.appendChild(initFreq);
        tuning.appendChild(currFreq);
      }
      
      // set viewpoint
      refEdge = 0;
      let x = Math.sqrt(halfShear[refEdge]);
      unframe = mat4.fromValues(
        1/x,   0, 0, 0,
        0,   1/x, 0, 0,
        0,     0, x, 0,
        0,     0, 0, x
      );
      
      // set boundary color
      bdryColor = [0, 0, 0];
      for (let c = 0; c < 3; c++) {
        for (let k = 0; k < n_edges; k++) {
          bdryColor[c] += edgeColor[3*k+c];
        }
        bdryColor[c] = (bdryColor[c]/n_edges + bgColor[c]) / 2;
      }
    }
    
    // triangulation and shear coordinates
    /*[1, 1, 1, 1, 1, 1] // Farey tesselation */
    /*[1, 27/32, 2/3, 9/16, 1/2, 3/4] // minor pentatonic scale */
    var initLambda
    var lambda;
    var n_edges;
    var halfLambda;
    var halfShear;
    var leftOffset;
    var rightOffset;
    var oppOffset;
    var nextEdge;
    
    // flip stack
    var flipStack;
    
    function changeInitFreq(edge, initFreq) {
      let freq = Fraction(initFreq.value);
      console.log(freq);
      if (freq) {
        // change initial lambda length
        initLambda[edge] = freq.inverse();
        
        // propagate change to current lambda lengths
        lambda = initLambda.map(x => x.clone());
        flipStack.forEach(ptolemy => ptolemy.apply(lambda));
        halfLambda = lambda.map(Math.sqrt);
        updateAllShears();
        updateAllOffsets();
        updateCurrFreqInputs();
      } else {
        freq = initLambda[edge].inverse();
      }
      initFreq.value = freq.toFraction();
    }
    
    function changeCurrFreq(edge, currFreq) {
      let freq = Fraction(currFreq.value);
      console.log(freq);
      if (freq) {
        // change current lambda length
        lambda[edge] = freq.inverse();
        halfLambda[edge] = Math.sqrt(lambda[edge]);
        let edge_inv = edge + n_edges;
        updateShear(edge);
        updateShear(left(edge));
        updateShear(right(edge));
        updateShear(left(edge_inv));
        updateShear(right(edge_inv));
        updateOffsets(edge);
        updateOffsets(edge_inv);
        updateOffsets(inv(left(edge)));
        updateOffsets(inv(right(edge)));
        updateOffsets(inv(left(edge_inv)));
        updateOffsets(inv(right(edge_inv)));
        
        // propagate change to current lambda lengths
        initLambda = lambda.map(x => x.clone());
        for (let n = flipStack.length-1; n >= 0; n--) {
          console.log('propagate', n);
          flipStack[n].apply(initLambda);
        }
        updateInitFreqInputs();
      } else {
        freq = lambda[edge].inverse();
      }
      currFreq.value = freq.toFraction();
    }
    
    function updateInitFreqInputs() {
      for (let k = 0; k < n_edges; k++) {
        initFreq = document.querySelector('#init-freq' + String(k));
        initFreq.value = initLambda[k].inverse().toFraction();
      }
    }
    
    function updateCurrFreqInputs() {
      for (let k = 0; k < n_edges; k++) {
        currFreq = document.querySelector('#curr-freq' + String(k));
        currFreq.value = lambda[k].inverse().toFraction();
      }
    }
    
    // display parameters
    var bgColor = [1/128, 1/128, 1/128];
    var bdryColor;
    
    // viewpoint
    var refEdge;
    var unframe;
    
    function left(edge) {
      return nextEdge[2*edge];
    }
    
    function right(edge) {
      return nextEdge[2*edge+1];
    }
    
    function inv(edge) {
      return (edge + n_edges) % (2*n_edges);
    }
    
    function updateShear(edge) {
      let edge_inv = inv(edge);
      halfShear[edge % n_edges] = (
        halfLambda[left(edge) % n_edges] * halfLambda[left(edge_inv) % n_edges] /
        (halfLambda[right(edge) % n_edges] * halfLambda[right(edge_inv) % n_edges])
      );
    }
    
    function updateAllShears() {
      for (let k = 0; k < n_edges; k++) {
        updateShear(k);
      }
      sceneChanged = true;
    }
    
    function updateOffsets(edge) {
      // remember, the additive lambda length is *half* the distance between the
      // horocycles. see Penner's _Decorated Teichmüller Theory,_ definition 4.4
      leftOffset[edge] = (
        lambda[edge % n_edges] * lambda[left(edge) % n_edges] /
        lambda[right(edge) % n_edges]
      );
      rightOffset[edge] = (
        lambda[right(edge) % n_edges] * lambda[edge % n_edges] /
        lambda[left(edge) % n_edges]
      );
      oppOffset[edge] = (
        lambda[left(edge) % n_edges] * lambda[right(edge) % n_edges] /
        lambda[edge % n_edges]
      );
    }
    
    function updateAllOffsets() {
      for (let k = 0; k < 2*n_edges; k++) {
        updateOffsets(k);
      }
      sceneChanged = true;
    }
    
    function reverseRefEdge() {
      refEdge = inv(refEdge);
      let x = halfShear[refEdge % n_edges];
      mat4.multiply(
        unframe,
        mat4.fromValues(
            0,   0, -x,  0,
            0,   0,  0, -x,
          1/x,   0,  0,  0,
            0, 1/x,  0,  0
        ),
        unframe
      );
    }
    
    function slitherRefEdgeLeft() {
      refEdge = left(refEdge);
      let x = halfShear[refEdge % n_edges];
      mat4.multiply(
        unframe,
        mat4.fromValues(
          1/x,   0, -x,  0,
            0, 1/x,  0, -x,
            0,   0,  x,  0,
            0,   0,  0,  x
        ),
        unframe
      );
    }
    
    function slitherRefEdgeRight() {
      refEdge = right(refEdge);
      let x = halfShear[refEdge % n_edges];
      mat4.multiply(
        unframe,
        mat4.fromValues(
           1/x,    0, 0, 0,
             0,  1/x, 0, 0,
          -1/x,    0, x, 0,
             0, -1/x, 0, x
        ),
        unframe
      );
    }
    
    class Ptolemy {
      edge
      nigh
      
      constructor(edge, nigh) {
        this.edge = edge % n_edges;
        this.nigh = nigh.map(k => k % n_edges);
      }
      
      apply(lam) {
        lam[this.edge] = lam[this.nigh[0]].mul(lam[this.nigh[2]]).add(
          lam[this.nigh[1]].mul(lam[this.nigh[3]])
        ).div(lam[this.edge]);
      }
    }
    
    function flip(edge) {
      // get relevant edges
      let edge_inv = inv(edge);
      let nigh = [right(edge), left(edge), right(edge_inv), left(edge_inv)];
      let nigh_inv = nigh.map(inv);
      
      // we can't flip a self-folded edge
      if ((edge - nigh[0]) % n_edges == 0 || (edge - nigh[1]) % n_edges == 0) {
        return false;
      }
      
      // avoid flipping the reference edge by moving the reference edge if
      // necessary
      refEdge_inv = inv(refEdge);
      if ((edge - refEdge) % n_edges == 0) {
        if ((left(refEdge) - right(refEdge)) % n_edges == 0) {
          // the reference edge faces into a self-folded triangle
          reverseRefEdge();
          slitherRefEdgeLeft();
        } else if (
          (left(refEdge) - left(refEdge_inv)) % n_edges == 0 ||
          (left(refEdge) - right(refEdge_inv)) % n_edges == 0
        ) {
          // slithering the reference edge left would make it face itself again
          slitherRefEdgeRight();
        } else {
          // this includes the case where the reference edge faces out of a
          // self-folded triangle
          slitherRefEdgeLeft();
        }
      }
      
      // avoid flipping an edge that the reference edge faces by moving the
      // reference edge if necessary
      if ((left(refEdge) - edge) % n_edges == 0) {
        if (
          (left(refEdge_inv) - edge) % n_edges == 0 ||
          (right(refEdge_inv) - edge) % n_edges == 0
        ) {
          slitherRefEdgeRight();
        } else {
          reverseRefEdge();
        }
      }
      if ((right(refEdge) - edge) % n_edges == 0) {
        if (
          (left(refEdge_inv) - edge) % n_edges == 0 ||
          (right(refEdge_inv) - edge) % n_edges == 0
        ) {
          slitherRefEdgeLeft();
        } else {
          reverseRefEdge();
        }
      }
      
      // update lambda length
      ptolemy = new Ptolemy(edge, nigh);
      ptolemy.apply(lambda);
      
      // update half lambda length
      halfLambda[edge % n_edges] = Math.sqrt(lambda[edge % n_edges]);
      
      // update paths out of quadrilateral
      nextEdge[2*edge+1] = nigh[1];
      nextEdge[2*edge] = nigh[2];
      nextEdge[2*edge_inv+1] = nigh[3];
      nextEdge[2*edge_inv] = nigh[0];
      
      // update paths into quadrilateral
      nextEdge[2*nigh_inv[0]] = nigh[3];
      nextEdge[2*nigh_inv[0]+1] = edge;
      nextEdge[2*nigh_inv[1]] = edge_inv;
      nextEdge[2*nigh_inv[1]+1] = nigh[2];
      nextEdge[2*nigh_inv[2]] = nigh[1];
      nextEdge[2*nigh_inv[2]+1] = edge_inv;
      nextEdge[2*nigh_inv[3]] = edge;
      nextEdge[2*nigh_inv[3]+1] = nigh[0];
      
      // update shear coordinates
      updateShear(edge);
      for (let k = 0; k < 4; k++) {
        updateShear(nigh[k]);
      }
      
      // update note frequencies
      updateNote(edge % n_edges);
      
      // update current frequency input
      currFreq = document.querySelector('#curr-freq' + String(edge));
      currFreq.value = lambda[edge % n_edges].inverse().toFraction();
      
      // flag scene change
      sceneChanged = true;
      
      // add flip to stack
      if (flipStack.length > 0 && ptolemy.edge === flipStack[flipStack.length-1].edge) {
        // this flip undid the last one
        flipStack.pop();
      } else {
        flipStack.push(ptolemy);
      }
      
      // report success
      return true;
    }
    
    // --- triangulation interactions ---
    
    const vec4 = glMatrix.vec4;
    
    const view = 1.02;
    
    var pointerVec = mat4.create();
    
    // the mobius transformation that maps the unit disk to the upper half-
    // plane, fixing 1 and -1
    const unroll = mat4.fromValues(
       0, 1,  1, 0,
      -1, 0,  0, 1,
       1, 0,  0, 1,
       0, 1, -1, 0
    );
    mat4.multiplyScalar(unroll, unroll, 1/Math.sqrt(2));
    
    function planeProj(out, event) {
      let rect = event.target.getBoundingClientRect();
      let shortdim = Math.min(rect.width, rect.height);
      vec4.set(
        out,
        view * (2*(event.clientX - rect.left) - rect.width) / shortdim,
        view * (2*(rect.bottom - event.clientY) - rect.height) / shortdim,
        1,
        0
      );
      vec4.transformMat4(out, out, unroll);
      vec4.transformMat4(out, out, unframe);
      
      // return the inner radius of a pixel in the Euclidean metric of the screen
      return view / shortdim;
    }
    
    // the mobius transformation that gives the upper half-plane a half-turn
    // around `i`
    const halfTurn = mat4.fromValues(
      0, 0, -1,  0,
      0, 0,  0, -1,
      1, 0,  0,  0,
      0, 1,  0,  0
    );
    
    // left and right turns
    const leftMat = mat4.fromValues(
      1, 0, -1,  0,
      0, 1,  0, -1,
      0, 0,  1,  0,
      0, 0,  0,  1
    );
    const rightMat = mat4.fromValues(
       1,  0, 0, 0,
       0,  1, 0, 0,
      -1,  0, 1, 0,
       0, -1, 0, 1
    );
    
    var walkVec = vec4.create();
    
    function address(planeVec, r_px) {
      v = walkVec;
      vec4.copy(v, planeVec);
      
      height = v[0]*v[3] - v[1]*v[2];
      if (height > 0) {
        // departure
        let edge = refEdge;
        if (v[0]*v[2] + v[1]*v[3] < 0.) {
          vec4.transformMat4(v, v, halfTurn);
          edge = (edge + n_edges) % (2*n_edges);
        }
        
        // during the walk, we'll use these to see whether we're beyond the left
        // and right sides of the triangle. when we arrive, we'll use them
        // to find the signed distances to the sides of the triangle
        let m; // Re(ab')
        let q_a; // |a|^2
        let q_b; // |b|^2
        
        // later steps
        const stepMax = 40;
        let step;
        for (step = 0; step < stepMax; step++) {
          // shear the opposite vertex to 1
          if (step > 0 || edge != refEdge) {
            let x = halfShear[edge % n_edges];
            v[0] /= x;
            v[1] /= x;
            v[2] *= x;
            v[3] *= x;
          }
          
          // set up to find the signed distances to the left and right sides.
          // we look at `v` as a pair `(a, b)` of complex numbers
          m = v[0]*v[2] + v[1]*v[3]; // Re(ab')
          q_a = v[0]*v[0] + v[1]*v[1]; // |a|^2
          q_b = v[2]*v[2] + v[3]*v[3]; // |b|^2
          
          leftEdge = left(edge);
          rightEdge = right(edge);
          if (m > q_a) {
            vec4.transformMat4(v, v, leftMat);
            edge = leftEdge;
          } else if (m > q_b) {
            vec4.transformMat4(v, v, rightMat);
            edge = rightEdge;
          } else {
            break;
          }
        }
        
        // --- arrival ---
        
        // `t_side := tanh(d_side)`, where `d_side` is the distance from `v` to
        //  a side of the triangle
        //
        // the base side of the triangle is the geodesic from 0 to infinity in
        // the upper half-plane. the curve through `v` which is equidistant from
        // the base side is a ray which leaves 0 at some angle `phi`. the
        // distance from `v` to the base side is given by (Series, "Hyperbolic
        // Geometry: MA 448", section 2.2.7)
        //
        //   tanh(d_base) = cos(phi)
        //
        // the distances to the left and right sides can be found similarly
        let diff_re = v[0] - v[2]
        let diff_im = v[1] - v[3];
        let diff = Math.hypot(diff_re, diff_im, diff_re, diff_im); // |a - b|
        let t_base = m / Math.sqrt(q_a * q_b);
        let t_left = (m - q_a) / (Math.sqrt(q_a) * diff);
        let t_right = (m - q_b) / (Math.sqrt(q_b) * diff);
        
        // find the nearest edge
        let t_near = t_base;
        let nearEdge = edge;
        if (-t_left < Math.abs(t_near)) {
          t_near = t_left;
          nearEdge = left(edge);
        }
        if (-t_right < Math.abs(t_near)) {
          t_near = t_right;
          nearEdge = right(edge);
        }
        
        // check whether we're within the nearest edge's active width
        let projScaling = 2 / height; // the conformal scale factor of the projection
        let width = Math.min(40, 120/Math.sqrt(0.5*projScaling));
        if (Math.abs(t_near) < projScaling * (0.5 * width * r_px)) {
          return [nearEdge % n_edges];
        } else if (step < stepMax) {
          return [edge % n_edges, leftEdge % n_edges, rightEdge % n_edges];
        } else {
          return [];
        }
        /*return nearEdge % n_edges;*/
      } else {
        // we're outside the upper half-plane
        return [];
      }
    }
    
    function instrumentMouseDown(event) {
      let r_px = planeProj(pointerVec, event);
      let edges = address(pointerVec, r_px);
      if (event.shiftKey && edges.length == 1) {
        if (flip(edges[0])) {
          console.log('mouse: flip', edges);
        } else {
          console.log('mouse: couldn\'t flip', edges);
        }
      } else {
        console.log('mouse: play', edges);
        edges.forEach(playNote);
      }
    }
    
    const pedalTouches = new Map();
    
    function forEachChangedTouch(event, action) {
      touches = event.changedTouches;
      for (let m = 0; m < touches.length; m++) action(touches[m]);
      event.preventDefault();
    }
    
    function instrumentTouchStart(touch) {
      let r_px = planeProj(pointerVec, touch);
      if (pointerVec[0]*pointerVec[3] - pointerVec[1]*pointerVec[2] > 0) {
        let edges = address(pointerVec, r_px);
        if (pedalTouches.size === 0) {
          console.log('touch: play', edges);
          edges.forEach(playNote);
        } else if (edges.length === 1) {
          if (flip(edges[0])) {
            console.log('touch: flip', edges[0]);
          } else {
            console.log("touch: couldn't flip", edges[0]);
          }
        } else {
          console.log('touch with pedal down');
        }
      } else {
        pedalTouches.set(touch.identifier, true);
      }
    }
    
    function instrumentTouchDrop(touch) {
      if (pedalTouches.has(touch.identifier)) pedalTouches.delete(touch.identifier);
    }

    // binding
    function bindPointer(element) {
      // adding a 'touchstart' listener stops mobile browsers (Chrome, at least)
      // from firing a mousedown event when you tap
      element.addEventListener('mousedown', instrumentMouseDown);
      element.addEventListener(
        'touchstart',
        event => forEachChangedTouch(event, instrumentTouchStart)
      );
      element.addEventListener(
        'touchend',
        event => forEachChangedTouch(event, instrumentTouchDrop)
      );
      element.addEventListener(
        'touchcancel',
        event => forEachChangedTouch(event, instrumentTouchDrop)
      );
    }

    // --- viewpoint interactions ---

    const viewSpeed = 0.1; // in curvature units per second

    var lastTime = 0;

    var walk = 0;
    var fStrafe = 0;
    var bStrafe = 0;
    const vUnframe = mat4.create();
    const stepUnframe = mat4.create();

    // matrix exponential. default number of terms imitates the Julia base
    // library's `expm1_small`
    const term = mat4.create();
    function quickExp(out, a, nTerms = 12) {
      mat4.identity(out);
      mat4.copy(term, a);
      mat4.add(out, out, term);
      for (let n = 2; n < nTerms; n++) {
        mat4.multiply(term, a, term);
        mat4.multiplyScalar(term, term, 1/n);
        mat4.add(out, out, term);
      }
    }

    function viewKeyDown(event) {
      if (event.key === 'd') walk = -viewSpeed;
      else if (event.key === 'e') walk = viewSpeed;
      else if (event.key === 'w') fStrafe = -viewSpeed;
      else if (event.key === 'r') fStrafe = viewSpeed;
      else if (event.key === 's') bStrafe = -viewSpeed;
      else if (event.key === 'f') bStrafe = viewSpeed;
      sceneChanged = true;
    }

    function viewKeyUp(event) {
      if (event.key === 'd' || event.key === 'e') walk = 0;
      else if (event.key === 's' || event.key === 'f') bStrafe = 0;
      else if (event.key === 'w' || event.key === 'r') fStrafe = 0;
      sceneChanged = true;
    }

    function viewMoving() {
      return walk != 0 || fStrafe != 0 || bStrafe != 0;
    }

    // binding
    function bindKeyboard(element) {
      element.addEventListener('keydown', viewKeyDown);
      element.addEventListener('keyup', viewKeyUp);
    }

    // --- initialize triangulation ---

    const tetrahedron = new Triangulation(
      /*[
        Fraction(1),
        Fraction(4, 5),
        Fraction(2, 3),
        Fraction(3, 5),
        Fraction(1, 2),
        Fraction(3, 4)
      ],*/
      [
        Fraction(1),
        Fraction(1),
        Fraction(1),
        Fraction(1),
        Fraction(1),
        Fraction(1)
      ],
      [
        3, 5+6,
        4, 3+6,
        5, 4+6,
        1+6, 4,
        2+6, 5,
        0+6, 3,
        2, 1,
        0, 2,
        1, 0,
        5+6, 0+6,
        3+6, 1+6,
        4+6, 2+6
      ]
    );
    
    /*const simpleTorus = new Triangulation(
      [
        Fraction(1),
        Fraction(2, 3),
        Fraction(3, 4)
      ],
      [
        1, 2,
        2+3, 0,
        0, 1+3,
        1+3, 2+3,
        2, 0+3,
        0+3, 1
      ]
    );*/

    const hexTorus = new Triangulation(
      // some nice chord changes
      /*[
        Fraction(1),
        Fraction(4, 5),
        Fraction(3, 2),
        Fraction(1, 2),
        Fraction(3, 5),
        Fraction(3, 4)
      ],*/
      [
        Fraction(2),
        Fraction(3/2),
        Fraction(4/3),
        Fraction(5/4),
        Fraction(5/2),
        Fraction(3)
      ],
      /*
      // lots of 9 denominators
      [
        Fraction(1),
        Fraction(4, 5),
        Fraction(2, 3),
        Fraction(1, 2),
        Fraction(3, 5),
        Fraction(3, 4)
      ],
      */
      [
        3, 5+6,
        4, 3+6,
        5, 4+6,
        1+6, 4,
        2+6, 5,
        0+6, 3,
        1, 2,
        2, 0,
        0, 1,
        5+6, 0+6,
        3+6, 1+6,
        4+6, 2+6
      ]
    );
    
    // set up surface selector
    surfList = [tetrahedron, hexTorus];
    surf.addEventListener('change', () => {
      setTriangulation(surfList[surf.selectedIndex]);
      sceneChanged = true;
    });
    setTriangulation(surfList[surf.selectedIndex]);
    console.log(
      halfShear,
      nextEdge,
      edgeColor,
      n_edges,
      refEdge,
      unframe,
      view,
      bgColor,
      bdryColor
    )
    
    // --- get canvases and hook up interactions ---
    
    var testCanvas = document.querySelector('#test');
    bindPointer(testCanvas);
    bindKeyboard(window);
    
    // --- initialize shaders ---
    
    const arrays = {
      position: [
        // northwest triangle
        -1, -1, 0,
        -1,  1, 0,
         1,  1, 0,
        // southeast triangle
        -1, -1, 0,
         1,  1, 0,
         1, -1, 0
      ]
    };
    
    const ctx = testCanvas.getContext('webgl2');
    const programInfo = twgl.createProgramInfo(ctx, ['pass-vert', 'test-frag']);
    const bufferInfo = twgl.createBufferInfoFromArrays(ctx, arrays);
    
    // --- define rendering routine ---
    
    var sceneChanged = true;
    
    function render(time) {
      // handle keyboard input
      const timeStep = 0.001*(time - lastTime);
      mat4.set(vUnframe,
          -walk,       0, bStrafe,       0,
              0,   -walk,       0, bStrafe,
        fStrafe,       0,    walk,       0,
              0, fStrafe,       0,    walk
      );
      mat4.multiplyScalar(vUnframe, vUnframe, timeStep);
      quickExp(stepUnframe, vUnframe);
      mat4.multiply(unframe, unframe, stepUnframe);
      lastTime = time;

      if (sceneChanged) {
        // size canvas
        console.log("repaint");
        twgl.resizeCanvasToDisplaySize(testCanvas);
        
        // paint canvas
        ctx.useProgram(programInfo.program);
        twgl.setBuffersAndAttributes(ctx, programInfo, bufferInfo);
        twgl.setUniforms(programInfo, {
          resolution: [ctx.canvas.width, ctx.canvas.height],
          shortdim: Math.min(ctx.canvas.width, ctx.canvas.height),
          dpr: window.devicePixelRatio,
          half_shear: halfShear,
          left_offset: leftOffset,
          right_offset: rightOffset,
          opp_offset: oppOffset,
          next_edge: nextEdge,
          edge_color: edgeColor,
          n_edges: n_edges,
          ref_edge: refEdge,
          unframe: unframe,
          view: view,
          bg_color: bgColor,
          bdry_color: bdryColor
        });
        twgl.drawBufferInfo(ctx, bufferInfo);
        
        // clear scene change flag
        sceneChanged = viewMoving();
      }
      
      // request next frame
      requestAnimationFrame(render);
    }
    
    // kick off animation
    requestAnimationFrame(render);
    
    // --- set up audio ---
    
    // get tone control
    tone = document.querySelector("#tone");
    
    // main context
    var audioContext = new (window.AudioContext || window.webkitAudioContext)();
    var mainAmp = audioContext.createGain();
    mainAmp.connect(audioContext.destination);
    mainAmp.gain.value = 0.25; /* range 0 to 1 */
    
    // edge tones
    var edgeOsc = Array(n_edges);
    edgeOsc.fill(null);
    var edgeAmp = Array(n_edges);
    var shepardOsc = Array(n_edges);
    var shepardAmp = Array(n_edges);
    const shepardRange = 9;
    const shepardLow = 3; // log(frequency / Hz)
    const shepardHigh = shepardLow + shepardRange;
    for (let k = 0; k < n_edges; k++) {
      edgeAmp[k] = audioContext.createGain();
      edgeAmp[k].connect(mainAmp);
      shepardOsc[k] = Array(shepardRange);
      shepardOsc[k].fill(null);
      shepardAmp[k] = Array(shepardRange);
      for (let j = 0; j < shepardRange; j++) {
        shepardAmp[k][j] = audioContext.createGain();
        shepardAmp[k][j].connect(edgeAmp[k]);
      }
    }
    
    const t_attack = 0.02;
    const t_decay = 2;
    const t_release = 0.02;
    const t_glide = 0.04;
    
    function playNote(edge_u) {
      console.log(lambda[edge_u]);
      var now = audioContext.currentTime;
      var amp = edgeAmp[edge_u];
      if (!edgeOsc[edge_u] && !shepardOsc[edge_u][0]) {
        // set attack and decay
        /*amp = edgeAmp[edge_u];*/
        amp.gain.setValueAtTime(0, now);
        amp.gain.linearRampToValueAtTime(1, now + t_attack);
        amp.gain.exponentialRampToValueAtTime(0.005, now + t_attack + t_decay);
        amp.gain.linearRampToValueAtTime(0, now + t_attack + t_decay + t_release);
        
        if (tone.selectedIndex === 0) {
          // create and start oscillator
          let osc = audioContext.createOscillator();
          osc.frequency.setValueAtTime(220 / lambda[edge_u], now);
          osc.addEventListener('ended', event => {
            event.target.disconnect();
            edgeOsc[edge_u] = null;
          });
          osc.connect(amp);
          osc.start();
          osc.stop(now + t_attack + t_decay + t_release);
          
          // save oscillator reference
          edgeOsc[edge_u] = osc;
        } else {
          let logFreq = Math.log2(220 / lambda[edge_u]); // log(frequency / Hz)
          logFreq += Math.ceil(shepardLow - logFreq);
          freq = Math.pow(2, logFreq);
          logFreqDiff = logFreq - shepardLow;
          for (let j = 0; j < shepardRange; j++) {
            // adjust amplitude
            let amp = shepardAmp[edge_u][j];
            let envelope = 1 - Math.cos(2*Math.PI * logFreqDiff / shepardRange);
            amp.gain.setValueAtTime(envelope / shepardRange, now);
            console.log(envelope);
            
            // create and start oscillator
            let osc = audioContext.createOscillator();
            osc.frequency.setValueAtTime(freq, now);
            osc.addEventListener('ended', event => {
              event.target.disconnect();
              shepardOsc[edge_u][j] = null;
            });
            osc.connect(amp);
            osc.start();
            osc.stop(now + t_attack + t_decay + t_release);
            
            // save oscillator reference
            shepardOsc[edge_u][j] = osc;
            
            // go to next octave
            logFreqDiff += 1;
            freq *= 2;
          }
        }
      } else {
        // restart attack and decay
        amp.gain.cancelScheduledValues(now);
        amp.gain.setValueAtTime(amp.gain.value, now);
        amp.gain.linearRampToValueAtTime(1, now + t_attack);
        amp.gain.exponentialRampToValueAtTime(0.005, now + t_attack + t_decay);
        amp.gain.linearRampToValueAtTime(0, now + t_attack + t_decay + t_release);
        
        // reschedule oscillator stop
        if (edgeOsc[edge_u]) {
          edgeOsc[edge_u].stop(now + t_attack + t_decay + t_release);
        } else {
          for (let j = 0; j < shepardRange; j++) {
            shepardOsc[edge_u][j].stop(now + t_attack + t_decay + t_release);
          }
        }
      }
    }
    
    /* not being used right now
    function stopNote(edge_u) {
      osc = edgeOsc[edge_u];
      if (osc) {
        now = audioContext.currentTime;
        end = now + t_release;
        let amp = edgeAmp[edge_u];
        amp.gain.cancelScheduledValues(now);
        amp.gain.setValueAtTime(amp.gain.value, now);
        amp.gain.linearRampToValueAtTime(0, end);
        osc.stop(end);
        
        return true;
      } else {
        return false;
      }
    }*/
    
    function updateNote(edge_u) {
      if (edgeOsc[edge_u] || shepardOsc[edge_u][0]) {
        let now = audioContext.currentTime;
        let end = now + t_glide;
        if (edgeOsc[edge_u]) {
          osc = edgeOsc[edge_u];
          osc.frequency.cancelScheduledValues(now);
          osc.frequency.setValueAtTime(osc.frequency.value, now);
          osc.frequency.linearRampToValueAtTime(220 / lambda[edge_u], end);
        } else {
          let logFreq = Math.log2(220 / lambda[edge_u]); // log(frequency / Hz)
          logFreq += Math.ceil(shepardLow - logFreq);
          freq = Math.pow(2, logFreq);
          logFreqDiff = logFreq - shepardLow;
          for (let j = 0; j < shepardRange; j++) {
            // update amplitude
            let amp = shepardAmp[edge_u][j];
            let envelope = 1 - Math.cos(2*Math.PI * logFreqDiff / shepardRange);
            amp.gain.cancelScheduledValues(now);
            amp.gain.setValueAtTime(amp.gain.value, now);
            amp.gain.linearRampToValueAtTime(envelope / shepardRange, end);
            
            // update frequency
            osc = shepardOsc[edge_u][j];
            osc.frequency.cancelScheduledValues(now);
            osc.frequency.setValueAtTime(osc.frequency.value, now);
            osc.frequency.linearRampToValueAtTime(freq, end);
            
            // go to next octave
            logFreqDiff += 1;
            freq *= 2;
          }
        }
      }
    }
  </script>
</body>
</html>
